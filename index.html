<!DOCTYPE html>
<html class="theme theme-black">
<head>
<meta charset="utf-8">
<title>选做题——AVC的实现</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-black.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-black">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="shpa" id="选做题avc的实现">选做题——AVC的实现</h1><p data-anchor-id="hglx"><code class="code-black">信安二班</code> <code class="code-black">李昊儒</code> <code class="code-black">2015301500099</code></p><hr><p data-anchor-id="tzlb">主要数据结构：位置<code class="code-black">/security/selinux/avc.c</code></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="99ie" style=""><ol class="linenums"><li class="L0"><code><span class="kwd">struct</span><span class="pln"> avc_entry </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    u32         ssid</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pln">    u32         tsid</span><span class="pun">;</span></code></li><li class="L3"><code><span class="pln">    u16         tclass</span><span class="pun">;</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> av_decision  avd</span><span class="pun">;</span></code></li><li class="L5"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> avc_xperms_node  </span><span class="pun">*</span><span class="pln">xp_node</span><span class="pun">;</span></code></li><li class="L6"><code><span class="pun">};</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="kwd">struct</span><span class="pln"> avc_node </span><span class="pun">{</span></code></li><li class="L9"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> avc_entry    ae</span><span class="pun">;</span></code></li><li class="L0"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> hlist_node   list</span><span class="pun">;</span><span class="pln"> </span><span class="com">/* anchored in avc_cache-&gt;slots[i] */</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> rcu_head     rhead</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pun">};</span></code></li><li class="L3"><code></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="kwd">struct</span><span class="pln"> avc_cache </span><span class="pun">{</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> hlist_head   slots</span><span class="pun">[</span><span class="pln">AVC_CACHE_SLOTS</span><span class="pun">];</span><span class="pln"> </span><span class="com">/* avc_node-&gt;list 的链表头*/</span></code></li><li class="L7"><code><span class="pln">    </span><span class="typ">spinlock_t</span><span class="pln">      slots_lock</span><span class="pun">[</span><span class="pln">AVC_CACHE_SLOTS</span><span class="pun">];</span><span class="pln"> </span><span class="com">/* 写操作的锁 */</span></code></li><li class="L8"><code><span class="pln">    </span><span class="typ">atomic_t</span><span class="pln">        lru_hint</span><span class="pun">;</span><span class="pln">   </span><span class="com">/*LRU提示回收扫描 */</span></code></li><li class="L9"><code><span class="pln">    </span><span class="typ">atomic_t</span><span class="pln">        active_nodes</span><span class="pun">;</span></code></li><li class="L0"><code><span class="pln">    u32         latest_notif</span><span class="pun">;</span><span class="pln">   </span><span class="com">/* 最新的撤销通知 */</span></code></li><li class="L1"><code><span class="pun">};</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="kwd">struct</span><span class="pln"> avc_callback_node </span><span class="pun">{</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">callback</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">u32 </span><span class="kwd">event</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pln">    u32 events</span><span class="pun">;</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> avc_callback_node </span><span class="pun">*</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L7"><code><span class="pun">};</span></code></li></ol></pre><p data-anchor-id="3hf3">为了更好的了解一下这些数据结构的关系，尝试着查看一下AVC的初始化函数：avc_init() <br>
位置<code class="code-black">/security/selinux/avc.c</code></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="fmln" style=""><ol class="linenums"><li class="L0"><code><span class="kwd">void</span><span class="pln"> __init avc_init</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> AVC_CACHE_SLOTS</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code><span class="pln">        INIT_HLIST_HEAD</span><span class="pun">(&amp;</span><span class="pln">avc_cache</span><span class="pun">.</span><span class="pln">slots</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span></code></li><li class="L6"><code><span class="pln">        spin_lock_init</span><span class="pun">(&amp;</span><span class="pln">avc_cache</span><span class="pun">.</span><span class="pln">slots_lock</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span></code></li><li class="L7"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code><span class="pln">    atomic_set</span><span class="pun">(&amp;</span><span class="pln">avc_cache</span><span class="pun">.</span><span class="pln">active_nodes</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span></code></li><li class="L9"><code><span class="com">/* 将avc_cache的active_nodes设置为0 */</span></code></li><li class="L0"><code><span class="pln">    atomic_set</span><span class="pun">(&amp;</span><span class="pln">avc_cache</span><span class="pun">.</span><span class="pln">lru_hint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span></code></li><li class="L1"><code><span class="com">/* 将avc_cache的lru_hint设置为0，它们必须是原子操作 */</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">    avc_node_cachep </span><span class="pun">=</span><span class="pln"> kmem_cache_create</span><span class="pun">(</span><span class="str">"avc_node"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> avc_node</span><span class="pun">),</span></code></li><li class="L4"><code><span class="pln">                    </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> SLAB_PANIC</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pln">    avc_xperms_cachep </span><span class="pun">=</span><span class="pln"> kmem_cache_create</span><span class="pun">(</span><span class="str">"avc_xperms_node"</span><span class="pun">,</span></code></li><li class="L6"><code><span class="pln">                    </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> avc_xperms_node</span><span class="pun">),</span></code></li><li class="L7"><code><span class="pln">                    </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> SLAB_PANIC</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">);</span></code></li><li class="L8"><code><span class="pln">    avc_xperms_decision_cachep </span><span class="pun">=</span><span class="pln"> kmem_cache_create</span><span class="pun">(</span></code></li><li class="L9"><code><span class="pln">                    </span><span class="str">"avc_xperms_decision_node"</span><span class="pun">,</span></code></li><li class="L0"><code><span class="pln">                    </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> avc_xperms_decision_node</span><span class="pun">),</span></code></li><li class="L1"><code><span class="pln">                    </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> SLAB_PANIC</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">);</span></code></li><li class="L2"><code><span class="pln">    avc_xperms_data_cachep </span><span class="pun">=</span><span class="pln"> kmem_cache_create</span><span class="pun">(</span><span class="str">"avc_xperms_data"</span><span class="pun">,</span></code></li><li class="L3"><code><span class="pln">                    </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> extended_perms_data</span><span class="pun">),</span></code></li><li class="L4"><code><span class="pln">                    </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> SLAB_PANIC</span><span class="pun">,</span><span class="pln"> NULL</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="2t4y">因为avc_cache中slots数据成员是一个结构数组，所以采取循环方式，对它的数据成员进行初始化。它的每一项是一个双向链表，调用INIT_LIST_HEAD（）便可以对其进行赋值为空链表。和它一起初始化的还有自旋锁。从上面的函数我们还不能看出avc_node和avc_cache之间的关系，必须通过它们的操作，如avc_insert，avc_lookup等，才能理解其中联系。它们是通过list_head数据结构联系在一起，avc_cache中的list_head数组中的中存储的是avc_node数据成员。这种设计很巧妙，有很多设计都是我们平时不能想象的，如通过数据成员指针，获取结构的指针。AVC整体的存储架构是Hash表。通过Hash表的思想，就能够比较容易的理解这段代码。</p><hr><p data-anchor-id="7hty">AVC提供了从安全服务器获得的访问策略的缓冲区（cache），提高了安全机制的运行性能。它提供了hook函数高效检查授权的接口，提供了安全服务器管理cache的接口。与hook函数的接口定义在include/avc.h中，与服务器的接口定义在include/avc_ss.h中，AVC代码在avc.c中。 <br>
首先介绍一下AVC的权限查询接口avc_has_perm()，定义位置<code class="code-black">/security/selinux/avc.c</code></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="x1mu" style=""><ol class="linenums"><li class="L0"><code><span class="kwd">int</span><span class="pln"> avc_has_perm</span><span class="pun">(</span><span class="pln">u32 ssid</span><span class="pun">,</span><span class="pln"> u32 tsid</span><span class="pun">,</span><span class="pln"> u16 tclass</span><span class="pun">,</span></code></li><li class="L1"><code><span class="pln">         u32 requested</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> common_audit_data </span><span class="pun">*</span><span class="pln">auditdata</span><span class="pun">)</span></code></li><li class="L2"><code><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> av_decision avd</span><span class="pun">;</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> rc</span><span class="pun">,</span><span class="pln"> rc2</span><span class="pun">;</span></code></li><li class="L5"><code></code></li><li class="L6"><code><span class="pln">    rc </span><span class="pun">=</span><span class="pln"> avc_has_perm_noaudit</span><span class="pun">(</span><span class="pln">ssid</span><span class="pun">,</span><span class="pln"> tsid</span><span class="pun">,</span><span class="pln"> tclass</span><span class="pun">,</span><span class="pln"> requested</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">avd</span><span class="pun">);</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pln">    rc2 </span><span class="pun">=</span><span class="pln"> avc_audit</span><span class="pun">(</span><span class="pln">ssid</span><span class="pun">,</span><span class="pln"> tsid</span><span class="pun">,</span><span class="pln"> tclass</span><span class="pun">,</span><span class="pln"> requested</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">avd</span><span class="pun">,</span><span class="pln"> rc</span><span class="pun">,</span><span class="pln"> auditdata</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span></code></li><li class="L9"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">rc2</span><span class="pun">)</span></code></li><li class="L0"><code><span class="pln">        </span><span class="kwd">return</span><span class="pln"> rc2</span><span class="pun">;</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> rc</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="2gz6">该函数的功能是检查权限并执行合适的统计检查。参数ssid是主体的安全标识，参数tsid，客体的安全标识，参数tclass是客体安全类型，参数requested是申请检查的权限，参数auditdata是附加的审计数据。检查AVC以确定是否为SID对（@ssid，@tsid）授予了@requested权限，根据@tclass解释权限，并在缓存未命中时调用安全服务器以获得新决策并将其添加到 缓存。 根据政策审核授权或拒绝权限。 如果所有的@请求的权限被授予，则返回0，如果任何权限被拒绝，则返回EACCES，或者在其他错误时返回另一个-errno。由源码我们可以看到该函数调用两个函数，一个是avc_has_perm_noaudit，一个是avc_audit，两个函数把整个功能划分成两部分，一部分是仲裁权限的，另一部分是负责审计。从源码中还可以看出函数的返回值与后者无关，完全由前者决定。</p><hr><p data-anchor-id="qevm">下面是权限检查但是不进行审计的函数检查AVC以确定是否为SID对（@ssid，@tsid）授予了@requested权限，根据@tclass解释权限，并在缓存未命中时调用安全服务器以获取新的决策并将其添加到 缓存。 返回@avd中的决定副本。 如果所有的@请求的权限被授予，则返回0， - 如果任何权限被拒绝，则返回％EACCES，或者在其他错误时返回另一个-errno。 这个函数通常由avc_has_perm（）调用，但是也可以直接调用来将权限检查和审计分开。 在必须锁定支票的情况下，应该放行审核。位置<code class="code-black">/security/selinux/avc.c</code></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="6rn4" style=""><ol class="linenums"><li class="L0"><code><span class="kwd">inline</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> avc_has_perm_noaudit</span><span class="pun">(</span><span class="pln">u32 ssid</span><span class="pun">,</span><span class="pln"> u32 tsid</span><span class="pun">,</span></code></li><li class="L1"><code><span class="pln">             u16 tclass</span><span class="pun">,</span><span class="pln"> u32 requested</span><span class="pun">,</span></code></li><li class="L2"><code><span class="pln">             </span><span class="kwd">unsigned</span><span class="pln"> flags</span><span class="pun">,</span></code></li><li class="L3"><code><span class="pln">             </span><span class="kwd">struct</span><span class="pln"> av_decision </span><span class="pun">*</span><span class="pln">avd</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pun">{</span></code></li><li class="L5"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> avc_node </span><span class="pun">*</span><span class="pln">node</span><span class="pun">;</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> avc_xperms_node xp_node</span><span class="pun">;</span></code></li><li class="L7"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> rc </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L8"><code><span class="pln">    u32 denied</span><span class="pun">;</span></code></li><li class="L9"><code></code></li><li class="L0"><code><span class="pln">    BUG_ON</span><span class="pun">(!</span><span class="pln">requested</span><span class="pun">);</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="pln">    rcu_read_lock</span><span class="pun">();</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">    node </span><span class="pun">=</span><span class="pln"> avc_lookup</span><span class="pun">(</span><span class="pln">ssid</span><span class="pun">,</span><span class="pln"> tsid</span><span class="pun">,</span><span class="pln"> tclass</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">unlikely</span><span class="pun">(!</span><span class="pln">node</span><span class="pun">))</span></code></li><li class="L6"><code><span class="pln">        node </span><span class="pun">=</span><span class="pln"> avc_compute_av</span><span class="pun">(</span><span class="pln">ssid</span><span class="pun">,</span><span class="pln"> tsid</span><span class="pun">,</span><span class="pln"> tclass</span><span class="pun">,</span><span class="pln"> avd</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">xp_node</span><span class="pun">);</span></code></li><li class="L7"><code><span class="pln">    </span><span class="kwd">else</span></code></li><li class="L8"><code><span class="pln">        memcpy</span><span class="pun">(</span><span class="pln">avd</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">node</span><span class="pun">-&gt;</span><span class="pln">ae</span><span class="pun">.</span><span class="pln">avd</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(*</span><span class="pln">avd</span><span class="pun">));</span></code></li><li class="L9"><code></code></li><li class="L0"><code><span class="pln">    denied </span><span class="pun">=</span><span class="pln"> requested </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">~(</span><span class="pln">avd</span><span class="pun">-&gt;</span><span class="pln">allowed</span><span class="pun">);</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">unlikely</span><span class="pun">(</span><span class="pln">denied</span><span class="pun">))</span></code></li><li class="L2"><code><span class="pln">        rc </span><span class="pun">=</span><span class="pln"> avc_denied</span><span class="pun">(</span><span class="pln">ssid</span><span class="pun">,</span><span class="pln"> tsid</span><span class="pun">,</span><span class="pln"> tclass</span><span class="pun">,</span><span class="pln"> requested</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> flags</span><span class="pun">,</span><span class="pln"> avd</span><span class="pun">);</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">    rcu_read_unlock</span><span class="pun">();</span></code></li><li class="L5"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> rc</span><span class="pun">;</span></code></li><li class="L6"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="b1xg">代码的思路主要是首先加上读保护锁，接着调用avc_lookup（）查询AVC缓冲向量，如果返回值为空，表示该权限以前没有被查找过，通过调用安全服务器（Security Server）提供的接口security_compute_av（）（如上图红色字体所示），获得策略决策avd。并把查询的结果插入到AVC缓冲区中。接着，把所获得策略决策保存到参数avd中，并检查权限是否得到允许。如果请求为空或者denied的参数不为0，且系统处于enforcing模式或者flags为AVC_STRICT标志是，返回拒绝消息。当系统不是enforcing模式且flags为没有含AVC_STRICT标志时，在avc  node查询命中时，需要对调用avc_update_node进行更新。如果请求不为空或者denied的参数为0，表示权限获得允许，返回值为0，即表示成功。最后调用rcu_read_unlock()解除读锁。</p></div>
</body>
</html>